Генерируем данные по некоторой известной функции (синус например). Зашумляем данные нормальным распределением.

Теорию можно вычитать в Кирпиче: 

- 70с. - пример для кусочно-линейных базисных функций
- 151с. - кубический
- 208с. - кубические сглаживающие сплайны
- 250с - бикубический
- 132c. - базисные линейные функции
- 152,212c. - матрицы жесткости для эрмитовых

Веса q определяют сплайн (его аналитический вид). Далее вычислять по значения сплайна по точкам в зависимости от попадания в тот или иной элемент

У локальной матрицы размер 4х4. У глобальной размер по количеству узлов.

Вид эрмитовых базисных функций кубических можно найти в кирпиче.

Очень упрощенная версия:

Создаем файл spline.txt, в котором записываем количество узлов и их координаты.

Создаем файл data.txt, в котором указываем количество данных и их координаты (x,y)

Дальше в проге создаем структуру elem, в которой есть n1, n2 и список номеров данных из файла data.txt

По этой структуре строим локальные матрицы, для 2 элементов они должны быть размером 2x2.
Итерируемся, меняя базисные функции: пси11, пси12, пси21, пси22.
Далее из этих базисных функций собираем глобальную функцию с помощью каких-то форм из учебного пособия (в папке NMM лежит)
Собирать надо не из форм, а суммировать элементы массивов, у которых номера глобальных базисных функций совпадают.
Размер глобальной матрицы - NxN, где N - количество узлов.
В итоге решаем СЛАУ из составленных глобальной матрицы и вектора b.

В методе написано, что вектор b размерности 2n потому что это для эрмитовых функций. Для линейных просто n.
ПОсле того как найду коэффициенты q сгенерировать 1000 значений x (например), по котором строить сплайн.

Для решения СЛАУ можно использовать решатели. В C++ есть LAPACK с функцией dgesv

Используем линейные базисные функции.

По этим данным строим локальные матрицы и вычисляем глобальную матрицу.

Выходные данные: веса q

Отчет:

- Титульный лист
- Задание
- Листинг кода
- Выводы